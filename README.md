# CfP: Calculation for Physics
lastest version: 1.2 (upload at 2024/3/22 CST)
# 一些废话
反正能找到这的大概也是认识我的人，咱就直接用中文写了(笑)。

最开始写这个是为了处理原子物理的作业……虽然后来发现用惯了组合量之后手算也挺简单的。

反正写都写了，有些已经发现的bug留着也不舒服，就改一下。
# 功能概要
"SN.py"提供科学计数法和有效数字功能(类SN，实例需要两个参数：值、有效数字位数(默认/最大值10)；多的参数别管它，是我用来简化程序的)

"Unit.py"提供识别字符串形式的单位的功能(类Unit，实例需要一个参数：单位(字符串，默认空字符串)；多的同上)

"Quantity.py"在调用前两个的基础上增加单位换算的功能(类Quantity，实例需要三个参数：值、单位(字符串，默认空字符串)、有效数字位数(默认/最大值10)；多的同上)
# 主要更新
1.可以识别"m9""J/(m/s)"这样幂指数形式或者有括号的单位了，之前需要很愚蠢地输入"m*m*m*m*m*m*m*m*m"或者提前去括号"J/m*s"

  (基本上就是支持你正常写单位的一切写法；"/s2"等于"*s-2"；
  
   单位后面直接接数字或者用"^""**"连接，但是不能只用一个乘号"*";
   
   单位和单位之间用乘号"*"或者除号"/"分割;
   
   所有乘号都可以改成中文输入法下的"·"，这是从网上复制SI导出单位的时候做的适配)
   
2.支持幂指数为小数的运算，虽然不知道有没有对应的物理含义

  (比如说你可以让一个物理量的单位是"负七分之一米"，用这个语句: a = Quantity(1, "m-1/7")，虽然被python处理之后print出来是小数形式的m-0.142857143)
  
这么看来也没有多少功能hhh
# SN.py
SN.py 可以单独使用，如果你只需要科学计数法(更准确地说是需要自动处理有效数字的功能，笑)而不需要单位运算的话。

实际上SN类我只写了abs_if_power一个方法，用于更改科学计数法的幂指数(或者更物理一点的说法叫"数量级")，它返回的是该数量级下的绝对值(浮点数)。str和show都是辅助将abs_if_power的结果可视化而已。

有需要可以自己加方法，或者告诉我需要什么功能，我来加。(前面说过了能看到这个的多半是认识我的人，所以联系方式就不用在这里给了吧hhh)

# Unit.py
Unit.py 没有单独使用的价值吧……它就是把你输入的一个字符串形式的单位转成双层列表的形式而已，而且会把所有非数字成分(我所说数字成分大概包括0123456789.()+-*/^)视作单位，比如下划线"_"或者"QAQ"。

你会发现我刚才说的数字成分里有括号……这个文件我写了两百多行(含空行和注释行)，主要都是为了写处理括号的功能了……写完之后发现根本没啥用啊，谁给单位打括号啊……

(写上面一行话的时候意识到我的括号处理程序不能处理括号里面只有数字成分的语句……又花了20分钟去修改，都准备直接重写inner_bracket方法了，犹豫了19分钟发现在str_unit里面加一句if就OK了……不得不说代码可能实现没准备写的功能也是一件很有意思的事情^_^)

这个文件里我写了很多方法，用来在字符串中提取数字成分/在字符串中提取非数字成分/字符串形式的单位转成列表/列表形式的单位转成字符串/列表形式单位格式化……

但只给Unit类写了一个方法list_copy，返回self.list这个双层列表的复制。一般我让b=a，本来是想修改b的时候保持a不变，但如果a是一个列表，修改b的时候a也会变；这时候要b=a.copy()才行；多层列表有一个copy库deepcopy可以用，我这里简单写了一个仅适用于双层列表的。

# Quantity.py
Quantity.py 必须和SN.py Unit.py两个文件放在同一文件夹下才能使用，因为Quantity.py在开始"from SN import SN""from Unit import Unit"

虽然Quantity很大程度上就是把Unit和SN拼在一起，但含空行和注释姑且还是有一百多行的，如果使用，建议新开一个.py文件"from Quantity import Quantity"

(如果要调用我预设的一些Quantity类实例，比如光速、质子质量、电子质量、普朗克常数、玻尔兹曼常数，可以"from Quantity import *")

Quantity.py里有个standard_base是国际单位制的七个基本单位，standard_dic则是其他单位与基本单位的换算关系(有的是间接换算)，我把一些常数也作为单位放了进去，这样可以直接light_speed = Quantity(1, "c")来生成类实例。

Quantity.py支持自然单位制，只要把NaturalUnit改成True就可以了。实际上我是用(MeV, h_, k, c)替代了基本单位里的(kg, s, K, m)，加上没有变的(A, mol, cd)，仍然是七个相互独立的单位。一般所说自然单位制把(h_, k, c)看作无量纲数1, 使用时自动过滤就好。(懒得写这功能)

同理，你可以任取七个相互独立的单位，把他们丢进natural_base，并且把SI基本单位到它们的换算关系写进natural_dic，那么把NaturalUnit改成True之后，运行的所有结果都是用你所取的七个单位表示的。

不改单位制的话，可以使用Quantity类的show方法规定单位



# 代码示例Code Example
Question: If one (wrongly) assumes that the decay of a neutron is a two-body decay, n -> p + e-, then what are the energy, momentum (in units of MeV) and beta of the electron after the decay?

我直接从NEO网课作业题里面copy过来的，所以是英文。翻译一下是："假设中子的衰变是两体衰变(中子 → 质子 + 电子)，那么衰变生成的电子的能量、动量(以MeV)为单位(就是自然单位制)、β(速度v/c光速)是多少？"

用能量守恒、动量守恒、能动量三角形解方程的过程我就不写了，解出来是电子能量Ee=(mn^2+me^2-mp^2)*c^2/(2*mn)

————开始写代码————

from Quantity import Quantity

c = Quantity(1, "c")

mp = Quantity(938.3, "MeV/c2", 4)

mn = Quantity(939.6, "MeV/c2", 4)

me = Quantity(0.511, "MeV/c2", 3)

Ee = (mn**2 + me**2 - mp**2) * c**2 / mn / 2

beta = (Quantity(1)-(me*c*c/Ee)**2)**0.5

pe = me * beta * c / (Quantity(1) - beta**2) ** 0.5

Ee.show("MeV")

pe.show("MeV/c")

beta.show("")

————执行结果————

1.2894 MeV

1.184 MeV/c

0.9180958555600001

好，你会发现出bug了，有效数字位数不对。这个先别管它，晚点我再修……

——————————————————————————————————————————————————————————————————

先验算一下结果对不对。

自然单位制下c=1，背了质子中子电子质量以MeV为单位的值的话，直接算就好

直接算的结果：

1.2992396344189985

1.1945302958256072

0.9194072164830349

hhh，误差允许范围内，还行吧？？？

Quantity在运算时，实际上是比设定的有效数字多保留了一位在运算，但是对于相对论因子γ=1/(1-β^2)^0.5这个玩意，在β接近1时，稍微有一点δβ，γ的变化都非常明显，所以两种算法结果有区别。在我看来，每一次运算都截断还更加合理(不是给自己的代码辩护(你信吗(笑)))。

————————————————————————————————————————————————————————————————————————

GitHub我还不是很会用，英文界面很多东西都看不懂，所以在上传更新的时候会遇到困难。先走一步看一步吧。

到最后，这个README99%是写给我自己看的哈哈哈(感谢README帮我找了两个bug(QAQ))
# 所以我说这个东西写了就没多大用啊哈哈哈哈
